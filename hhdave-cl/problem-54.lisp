(asdf:load-system :cl-ppcre)
(defun iota (count &optional (start 1)) 
  (loop for n from 1 to count for x from start collect x))

(defun group (sequence)  ; should be more general (with comparator and key really)
  (let ((groups (list (list (first sequence)))))
    (dolist (x (cdr sequence))
      (if (= x (first (first groups)))
          (push x (first groups))
          (push (list x) groups)))
    groups))

(defun card-rank (card) (+ 2 (position (elt card 0) "23456789TJQKA")))
(defun card-suit (card) (elt card 1))

(defun score-hand (hand)
  (let* ((flush     (not (find (card-suit (first hand)) hand :test-not 'eql :key 'card-suit)))
         (ranks     (sort (mapcar 'card-rank hand) '<))
         (straight  (equal ranks (iota 5 (first ranks))))
         (groups    (group ranks)))
    (flet ((groups-of (n)
             (remove n groups :test-not '= :key 'length))
           (make-hand-score (name rank ranked)
             (append (list name rank (reduce 'max ranked)) (reverse ranks))))
      (macrolet ((scores (&rest scores)
                   `(or ,@ (loop for (name ==/if test) in scores for rank downfrom (length scores)
                              collect `(let ((match ,test))
                                         (when match
                                           (make-hand-score ',name ,rank ,(if (eql ==/if '==) 'match 'ranks))))))))
        (scores ; highest scoring first
         (royal-flush      if   (and straight flush (= 10 (first ranks))))
         (straight-flush   if   (and straight flush))
         (four-of-a-kind   ==   (first (groups-of 4)))
         (full-house       ==   (and (groups-of 2) (first (groups-of 3))))
         (flush            if   flush)
         (straight         if   straight)
         (three-of-a-kind  ==   (first (groups-of 3)))
         (two-pairs        ==   (when (cdr (groups-of 2))
                                  (apply 'append (groups-of 2))))
         (one-pair         ==   (first (groups-of 2)))
         (high-card        ==   (last ranks)))))))

;; (taking the cdr of the score because the car is the score's name)
(defun greater-score-p (a b)
  (loop for p1 in (cdr a) for p2 in (cdr b)
     unless (= p1 p2) do (return-from greater-score-p (> p1 p2)))
  (error "Scores are tied - this wasn't supposed to happen!"))

(format t "Player 1 wins ~A time~:P~%"
        (count-if (lambda (row)
                    (greater-score-p (score-hand (subseq row 0 5))
                                     (score-hand (subseq row 5))))
                  (with-open-file (stream "./poker.txt")
                    (loop for line = (read-line stream nil) while line collect (cl-ppcre:split " " line)))))
